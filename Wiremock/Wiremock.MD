# Wiremock

## Для чего нужен Wiremock?

В больших распределённых системах часто возникают ситуации, когда один или несколько сервисов работают некорректно. Это 
ведёт к тому, что тестируемая система начинает сбоить и блокировать тестирование, тем самым возможны задержки в разработке 
и поставке нового функционала для бизнеса. Для большого продукта это очень критично ввиду того, что подобные задержки 
ведут к общему увеличению стоимости нового функционала.

Типичная схема взаимодействия сервисов выглядит следующим образом:

![Интеграция приложения с backend](integration_ok.png)

Проблемы на стороне какого-либо сервиса ведут к тому, что вся система работает некорректно:

![Проблемы с сервисами](services_problem.png)

Сложная интеграционная схема зависимостей (когда очень много сервисов взаимодействуют друг с другом), тоже является 
серьёзной проблемой для качественного тестирования.

Для того чтобы избежать таких ситуаций, стараются минимизировать зависимость от сторонних сервисов, используя вместо 
них заглушки. Наиболее удобным инструментом для создания заглушек является Wiremock.

Тестируемая система настраивается таким образом, чтобы в качестве backend использовался Wiremock:

![Интеграция приложения с Wiremock](wiremock_integration.png)

## Установка Wiremock

Для запуска Wiremock-сервера можно использовать Docker и официальный образ:
```
docker run -it --rm -p 8080:8080 --name wiremock wiremock/wiremock:3.1.0
```

После скачивания и монтирования образа, Wiremock-сервер будет доступен по адресу: `http://localhost:8080/`

## Взаимодействие с Wiremock

Взаимодействие с запущенным Wiremock-сервером осуществляется посредством отправки HTTP-запросов в двух направлениях:
1. Администрирование.
2. Вызов сохранённых заглушек.

### Администрирование

Администрирование позволяет осуществлять различные манипуляции с сервером. Для этого существует REST API интерфейс 
`http://localhost:8080/__admin/{handler}`. С помощью этого интерфейса возможно (в скобках название ручек):
- управление заглушками (mappings);
- журналирование запросов (requests);
- учёт некорректных заглушек (near-misses);
- запись событий (recordings);
- управление состояниями сценариев (scenarios);
- изменение системных настроек Wiremock-сервера (settings, reset, shutdown).

Для получения детальной информации по доступным методам можно перейти по адресу `{wiremock_url}/__admin/swagger-ui/`.

### Вызов сохранённых заглушек

Вызов заглушек осуществляется выполнением HTTP-запроса на адрес `http://localhost:8080/{mock_path}`, где `mock_path` – 
путь к заглушке, которая ранее была загружена через интерфейс администрирования для управления заглушками.

## Работа с заглушками на примере Postman-коллекции:

**ВНИМАНИЕ!** Все совпадения случайны.

Для интерактивного знакомства с возможностями Wiremock-сервера, добавим некоторые вводные. Пусть в качестве тестируемой
системы у нас будет веб-приложение оформления заказа в интернет-магазине. В интернет-магазине можно делать заказы только 
на самовывоз, а оплачивать наличными при получении.

Приложение будет состоять из трёх страниц:
- корзина;
- оформление заказа;
- спасибо за покупку.

Вот описание бэка, с которым будет взаимодействовать наш frontend:

![Как выглядит бэк](scheme.png)

На каждой странице вызываются свои методы.

Так, на странице корзины вызываются:
- `GET products` (получает расширенную информацию о товарах по их кодам);
- `POST orders` (создаёт черновик заказа).

На странице оформления вызываются:
- `POST ffo` (создаёт черновик заявки на самовывоз);
- `PUT ffo` (устанавливает пункт самовывоза в заявке на самовывоз для будущего заказа);
- `PATCH orders` (вносит изменения в заказ, например, при вводе ФИО);
- `POST confirm` (подтверждает оформление заказа).

На странице "Спасибо за покупку" вызывается метод `GET orders` (отображает покупателю информацию о созданном заказе).

Так как ни описанного сервиса, ни фронта не существует, мы просто будем симулировать их работу с помощью Postman и 
Wiremock.

> Используем Postman, чтобы не опираться на голую теорию и добавить немного интерактива. В 
> [этой коллекции](postman_wiremock.json) можно найти пару примеров взаимодействия с этим сервисом, а также 
> необходимые заглушки.
> Последовательность использования коллекции следующая:
> - запустить Wiremock-сервер;
> - отправить заглушки из коллекции на запущенный сервер;
> - отправлять запросы к заглушкам сервиса.

В данной коллекции для отправки заглушек на запущенный Wiremock-сервер используется метод 
`POST /__admin/mappings/import`. В него передаётся массив заглушек в следующем виде:
```
{
    mappings" : [
        {заглушка 1},
        {заглушка 2}
    ]
}
```

Для заглушки минимальный набор параметров может быть следующим:
```
{
    "request": {
        "method": "GET",
        "urlPath": "/api/products/",
        "queryParameters": {
            "in_cart": {
                "equalTo": "10001:1,10002:3,10005:20.5"
            }
        }
    },
    "response": {
        "status": 200,
        "headers": {
            "Content-Type": "application/json"
        },
        "jsonBody": [
            {
                "id": "10001",
                "name": "Рюкзак Erhaft Star M-2357",
                "stock": 12,
                "weight": 15.5
            },
            {
                "id": "10002",
                "name": "Пюре ФрутоНяня из говядины с овощами 100 г с 8 месяцев",
                "stock": 60,
                "weight": 2.3
            },
            {
                "id": "10005",
                "name": "Каша Fleur Alpine безмолочная гречневая гипоаллергенная 175г с 4мес",
                "stock": 5.5,
                "weight": 1
            }
        ]
    }
}
```

Заглушка состоит из:
1. `request` – объект, описывающий запрос, по которому Wiremock-сервер определяет запрошенную заглушку.
2. `response` – объект, описывающий ответ, который возвращается при запросе заглушки.

|            |                   | Описание поля                               |
|------------|-------------------|---------------------------------------------|
| `request`  |                   |                                             |
|            | `method`          | HTTP-метод запроса                          |
|            | `urlPath`         | путь до заглушки без учёта query-параметров |
|            | `queryParameters` | объект, описывающий query-параметры запроса |
| `response` |                   |                                             |
|            | `status`          | HTTP-код статуса ответа                     |
|            | `headers`         | объект, описывающий заголовки ответа        |
|            | `jsonBody`        | JSON-объект (или массив) с телом ответа     |

Рассмотрим подробнее доступные параметры заглушек, которые чаще всего используются. Часть из них можно увидеть в 
Postman-коллекции.

### `urlPath`, `urlPathTemplate`, `urlPathPattern`

Определяют путь до заглушки. Разница между ними описана в таблице ниже.

| Параметр          | Описание                                                                                                   |
|-------------------|------------------------------------------------------------------------------------------------------------|
| `urlPath`         | относительный путь до заглушки без учёта query-параметров. Может использоваться вместе с `queryParameters` |
| `urlPathTemplate` | относительный путь до заглушки с path-параметрами. Используется вместе с `pathParameters`                  |
| `urlPathPattern`  | относительный путь до заглушки, с использованием регулярных выражений                                      |

> В одной заглушке используется только один из параметров пути.

### `queryParameters`

Определяет query-параметры (то, что передаётся в строке запроса после символа `?`). Пример:

```
url/path?param1=value1&param2=value2
```

В Wiremock применяется следующим образом:
```
"urlPath": "/api/products/",
"queryParameters": {
    "in_cart": {
        "equalTo": "10001:1,10002:3,10005:20.5"
    }
}
```

> Внутри `queryParameters` могут быть использованы операторы сравнения и логические операторы.

### `pathParameters`

Определяет path-параметры (то, что передаётся в строке запроса). Пример:

```
url/path/value1/value2
```

В Wiremock применяется вместе с `urlPathTemplate` следующим образом:
```
"urlPathTemplate": "/api/ffo/{ffo_id}/",
"pathParameters": {
    "ffo_id": {
        "equalTo": "882"
    }
}
```

> Внутри `pathParameters` могут быть использованы операторы сравнения и логические операторы.

### `bodyPatterns`

Определяет шаблон тела запроса.

В Wiremock применяется следующим образом:
```
"urlPath": "/api/orders/",
"bodyPatterns": [
    {
        "equalToJson": {
            "products": [
                {
                    "id": "10005",
                    "quantity": 20.5
                },
                {
                    "id": "10002",
                    "quantity": 3
                },
                {
                    "id": "10001",
                    "quantity": 1
                }
            ]
        },
        "ignoreArrayOrder": true
    }
]
```

> Внутри `bodyPatterns` могут быть использованы параметры `ignoreArrayOrder`, `ignoreExtraElements`, а также операторы 
> сравнения и логические операторы.

### `ignoreArrayOrder`, `ignoreExtraElements`

| Параметр              | Описание                                                                                                                                      |
|-----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------|
| `ignoreArrayOrder`    | не учитывать порядок элементов массива/объекта (`["asd", "qwe"]` будет равно `["qwe", "asd"]`)                                                |
| `ignoreExtraElements` | не учитывать элементы, которые не перечислены в `bodyPatterns` (под шаблон `{"example": 1}` подойдёт объект `{"test": "test", "example": 1}`) |

`False` – значение по умолчанию для обоих параметров.

> Эти параметры применяются с `bodyPatterns`.

### `equalTo`, `equalToJson`, `contains`, `matches`

Операторы сравнения. Могут быть использованы для проверки любых параметров.

| Параметр      | Описание                                                                         |
|---------------|----------------------------------------------------------------------------------|
| `equalTo`     | проверяет точное соответствие (`"abc" equalTo "abc"`)                            |
| `equalToJson` | проверяет соответствие JSON-объекту (или массиву). Используется в `bodyPatterns` |
| `contains`    | проверяет вхождение (`"abc" contains "b"`)                                       |
| `matches`     | проверяет соответствие регулярному выражению (`"abc" matches ".b."`)             |

### `and`, `or`

Логические операторы. Позволяют объединять несколько условий.

Эта заглушка сработает двух случаях:
- когда в query передаётся значение `in_cart=10001:1,10002:3`;
- когда в query передаётся значение `10005:20.5`.
```
"urlPath": "/api/products/",
"queryParameters": {
    "in_cart": {
        "or": [
            {
                "equalTo": "10001:1,10002:3"
            },
            {
                "equalTo": "10005:20.5"
            }
        ]
    }
}
```

А эта сработает только в одном случае: когда `in_cart` содержит оба значения – `10001` и `10005` (например, 
`10001:1,10002:3,10005:20.5`).
```
"urlPath": "/api/products/",
"queryParameters": {
    "in_cart": {
        "and": [
            {
                "contains": "10001"
            },
            {
                "contains": "10005"
            }
        ]
    }
}
```

## Использование Wiremock для нагрузочных тестов

Wiremock обладает существенным быстродействием ввиду того, что при подготовке ответа на запрос от клиента отсутствует 
какая-либо сложная логика, которая есть у реального сервиса. Для нагрузочного тестирования необходимо применение 
параметров максимально приближённых к реальным.

Wiremock позволяет симулировать различные ситуации, в частности управлять задержкой ответа, возвращать битые 
ответы или обрывать соединение с клиентом.

### Управление задержкой ответа

Установка задержки ответа на заглушки означает, что ответ не будет возвращён клиенту, пока не прошло указанное в 
параметрах время. Wiremock поддерживает несколько вариантов управления задержкой ответа.

#### Фиксированная задержка

Устанавливает одинаковое время ответа на запрос. Чтобы применить глобально сразу ко всем заглушкам, необходимо  
отправить запрос `POST /__admin/settings` с телом:
```
{
    "fixedDelay": 500
}
```

Для применения на конкретную заглушку, необходимо добавить параметр `fixedDelayMilliseconds`:
```
{
    "request": {
        "method": "PUT",
        "urlPathPattern": "/api/ffo/.*"
    },
    "response": {
        "status": 400,
        "fixedDelayMilliseconds": 2000,
        "headers": {
            "Content-Type": "application/json"
        },
        "jsonBody": {
            "error": "Pickup point doesn't exist!"
        }
    }
}
```

#### Логнормальное распределение задержки

Устанавливает случайное значение времени задержки. При генерации используются следующие параметры:
- `median` – среднее время ответа. Так называемая задержка 50-го перцентиля. Означает, что 50% ответов на запросы 
  будут возвращены быстрее этого времени;
- `sigma` – стандартное отклонение. Чем больше это значение, тем дольше может быть ожидание ответа (отклонение от 
  среднего времени ответа).

Для глобального применения необходимо отправить запрос `POST /__admin/settings` с телом:
```
{
    "delayDistribution": {
        "type": "lognormal",
        "median": 90,
        "sigma": 0.1
    }
}
```

Для применения на конкретную заглушку:
```
{
    "request": {
        "method": "PUT",
        "urlPathPattern": "/api/ffo/.*"
    },
    "response": {
        "status": 400,
        "delayDistribution": {
            "type": "lognormal",
            "median": 90,
            "sigma": 0.1
        },
        "headers": {
            "Content-Type": "application/json"
        },
        "jsonBody": {
            "error": "Pickup point doesn't exist!"
        }
    }
}
```

#### Равномерное распределение задержки

Устанавливает случайное значение задержки из заданного диапазона. При генерации используются следующие параметры:
- `lower` – минимальная задержка;
- `upper` – максимальная задержка.

Для глобального применения необходимо отправить запрос `POST /__admin/settings` с телом:
```
{
    "delayDistribution": {
        "type": "uniform",
        "lower": 300,
        "upper": 500
    }
}
```

Для применения на конкретную заглушку:
```
{
    "request": {
        "method": "PUT",
        "urlPathPattern": "/api/ffo/.*"
    },
    "response": {
        "status": 400,
        "delayDistribution": {
            "type": "uniform",
            "lower": 300,
            "upper": 500
        },
        "headers": {
            "Content-Type": "application/json"
        },
        "jsonBody": {
            "error": "Pickup point doesn't exist!"
        }
    }
}
```

#### Разбиение ответа на части

Wiremock может отправлять ответ на запрос клиенту по частям. Это полезно для симуляции медленного интернет-соединения. 
При генерации используются следующие параметры:
- `numberOfChunks` – количество частей, на которые будет разбито тело ответа;
- `totalDuration` – суммарное время, в течение которого весь ответ будет возвращён.

Для применения на конкретную заглушку:
```
{
    "request": {
        "method": "PUT",
        "urlPathPattern": "/api/ffo/.*"
    },
    "response": {
        "status": 400,
        "chunkedDribbleDelay": {
            "numberOfChunks": 5,
            "totalDuration": 1000
        },
        "headers": {
            "Content-Type": "application/json"
        },
        "jsonBody": {
            "error": "Pickup point doesn't exist!"
        }
    }
}
```

В данном примере тело будет разбито на 5 частей, каждая из которых будет отправляться клиенту раз в 200 миллисекунд.

### Симуляция ошибок при формировании ответов

Для отправки битых ответов применяется параметр `fault` при формировании конкретной заглушки. Допустимые значения 
параметра:
- `EMPTY_RESPONSE` – возвращает пустой ответ;
- `MALFORMED_RESPONSE_CHUNK` – отправляет OK в заголовках, затем мусор, а после закрывает соединение;
- `RANDOM_DATA_THEN_CLOSE` – отправляет мусор, затем закрывает соединение;
- `CONNECTION_RESET_BY_PEER` – возвращает ошибку "Connection reset by peer".

Пример:
```
{
    "request": {
        "method": "PUT",
        "urlPathPattern": "/api/ffo/.*"
    },
    "response": {
        "fault": "MALFORMED_RESPONSE_CHUNK"
    }
}
```

## Управление параметрами для нагрузки

Wiremock поддерживает настройку определённых параметров путём их передачи при запуске сервера. Это делается следующим 
образом:
```
docker run -it --rm -p 8080:8080 --name wiremock wiremock/wiremock:3.1.0 --async-response-enabled true
```

В команде запуска `--async-response-enabled` – параметр, а `true` – его значение.

Для создания устойчивой системы на базе Wiremock, которая была бы способна справиться с серьёзной нагрузкой, необходимо
изменить ряд стандартных настроек. В этой части рассмотрим возможности для настройки Wiremock под нагрузочное тестирование, 
а также варианты запуска для распределения нагрузки.

### Асинхронная обработка запросов

Говоря о Wiremock-сервере в целом, стоит уточнить, что на самом деле сервером, отвечающим за приём и отправку данных
внутри Wiremock, является Jetty. Это веб-сервер, который обслуживает HTTP-соединения для подключения к Wiremock. По
умолчанию Jetty настроен так, что обработка входящих запросов осуществляется последовательно (синхронно). Это критично
для проведения нагрузочного тестирования, где, например, задана задержка отправки заглушки (см. предыдущую часть статьи).

Для включения параллельной (асинхронной) **обработки запросов** используется параметр `--async-response-enabled true`. 
Благодаря этому существенно увеличивается пропускная способность при множестве соединений. 

Дополнительно можно указать количество потоков, которые будут использованы для **обработки запросов**. Это можно сделать 
передав параметр `--async-response-threads 20` (10 – значение по умолчанию).

> Использование `--async-response-threads` имеет смысл только вместе с `--async-response-enabled true`.

### Тонкая настройка Jetty

Для оптимизации работы Jetty могут быть использованы следующие параметры:
- `--container-threads` – количество потоков, используемых для **приёма входящих запросов** (по умолчанию 10);
- `--jetty-acceptor-threads` – количество потоков, используемых для **обработки входящих запросов**;
- `--jetty-accept-queue-size` – размер очереди для **запросов, принятых в обработку**;
- `--jetty-header-request-size` – ограничение на размер заголовков **запроса**, например, `--jetty-header-request-size 16384` 
  (по умолчанию 8192K);
- `--jetty-header-response-size` – ограничение на размер заголовков **ответа**, например, `--jetty-header-request-size 16384` 
  (по умолчанию 8192K);

### Оптимизация производительности

Чтобы увеличить производительность, уменьшить нагрузку на CPU и оперативную память можно отключить логгирование:
- `--no-request-journal` – отключает журнал запросов, позволяет Wiremock-серверу долгое время работать без перезапуска
  (или сброса заглушек), т.к. снижается нагрузка на Java Heap память;
- `--disable-request-logging` – отключает логгирование запросов-ответов сторонними логгерами, позволяет оптимизировать
  нагрузку на процессор и оперативную память.

## Балансировка нагрузки

При использовании одного Wiremock-сервера для нагрузочного тестирования есть риск его отказа, поэтому чаще всего 
применяют несколько запущенных экземпляров на одной машине или на нескольких распределённых.

В качестве балансировщика обычно используется Nginx как наиболее современный, лёгкий и быстрый веб-сервер. Суть 
балансировки заключается в настройке конфигурации Nginx таким образом, чтобы входящие запросы перенаправлялись на 
наименее загруженный экземпляр Wiremock:

![Балансировка нагрузки на Wiremock-серверы](nginx_balancer.png)

При таком подходе несложно заметить один из подводных камней: экземпляры Wiremock независимы друг от друга и работа с 
набором заглушек в классическом понимании становится невозможна. При использовании интерфейса для администрирования 
заглушки будут отправлены на наименее загруженный сервер и при последующих запросах может возникнуть ситуация, когда 
запрос будет перенаправлен на сервер, на котором не будет ранее отправленных заглушек.

Для решения данной проблемы можно использовать:
- общую директорию заглушек для всех экземпляров Wiremock. Подходит для статических заглушек (те, которые готовятся заранее 
  и не меняются);
- параллельную загрузку набора заглушек сразу на все экземпляры перед тестом. Подходит для динамических заглушек (те, 
  которые готовятся непосредственно перед тестом и могут быть изменены или удалены).

> Для понимания того, как это можно организовать, ниже расположены пошаговые примеры.
> Условимся, что у нас уже существуют директории `/c/wiremock/mappings` и `/c/nginx` (`C:\wiremock` и `C:\nginx` для Windows).

### Общая директория для набора заглушек

Для начала создадим набор заглушек `test.json` для теста в директории `/c/wiremock/mappings`:
```
{
    "mappings": [
        {
            "request": {
                "method": "GET",
                "urlPath": "/api/test1/"
            },
            "response": {
                "status": 200,
                "headers": {
                    "Content-Type": "application/json"
                },
                "jsonBody": {
                    "test1": true
                }
            }
        },
        {
            "request": {
                "method": "GET",
                "urlPath": "/api/test2/"
            },
            "response": {
                "status": 200,
                "headers": {
                    "Content-Type": "application/json"
                },
                "jsonBody": {
                    "test2": true
                }
            }
        },
        {
            "request": {
                "method": "GET",
                "urlPath": "/api/test3/"
            },
            "response": {
                "status": 200,
                "headers": {
                    "Content-Type": "application/json"
                },
                "jsonBody": {
                    "test3": true
                }
            }
        }
    ]
}
```

Запустим в изолированных контейнерах Wiremock-сервера:
```
docker run -it --rm -p 8080:8080 -v /c/wiremock:/home/wiremock --name wiremock1 wiremock/wiremock:3.1.0
docker run -it --rm -p 8081:8080 -v /c/wiremock:/home/wiremock --name wiremock2 wiremock/wiremock:3.1.0
docker run -it --rm -p 8082:8080 -v /c/wiremock:/home/wiremock --name wiremock3 wiremock/wiremock:3.1.0
```

Параметр и значение `-v /c/wiremock:/home/wiremock` указывают на то, что директория `/c/wiremock` будет содержать 
заглушки, использование данного параметра для всех образов говорит о том, что эта же директория будет общей для всех.

Параметр и значение `-p 8080:8080` указывают на порты. Первый – порт, на который можно отправлять запросы **извне в 
контейнер**. Второй – порт, на который можно отправлять запросы **внутри контейнера**. Для каждого контейнера внешние 
порты разные, чтобы можно было достучаться до каждого Wiremock-сервера извне.

Создадим файл конфигурации `wiremock_balancer.conf` для Nginx в директории `/c/nginx`:
```
user nginx;

events {
    worker_connections   1000;
}

http {
    upstream wiremock {
        server wiremock1:8080;
        server wiremock2:8080;
        server wiremock3:8080;
    }

    server {
        listen 80;

        location / {
            proxy_pass http://wiremock;
        }
    }
}
```

Теперь смонтируем Nginx, указав путь до конфигурации веб-сервера:
```
docker create -it -p 8083:80  -v /c/nginx/wiremock_balancer.conf:/etc/nginx/nginx.conf:ro --name nginx nginx
```

Создадим сетевой мост между всеми контейнерами:
```
docker network create wiremock
docker network connect wiremock wiremock1
docker network connect wiremock wiremock2
docker network connect wiremock wiremock3
docker network connect wiremock nginx
```

И запустим Nginx:
```
docker start nginx
```

Чтобы убедиться, что заглушки работают на каждом экземпляре Wiremock, можно открыть их список через интерфейс 
администрирования:
```
http://localhost:8080/__admin/mappings
http://localhost:8081/__admin/mappings
http://localhost:8082/__admin/mappings
```

Теперь, при отправке запросов на ручки из набора заглушек, нагрузка будет распределена с помощью Nginx между несколькими 
экземплярами Wiremock-сервера.

### Параллельная загрузка набора заглушек сразу на все экземпляры

Для загрузки набора заглушек сразу на все экземпляры можно использовать интерфейс администрирования по отдельности на каждом 
экземпляре. Решение этого вопроса можно также доверить Nginx и использовать зеркалирование входящих запросов. Для этого 
изменим конфигурацию веб-сервера:
```
user nginx;

events {
    worker_connections   1000;
}

http {
    upstream wiremock {
        server wiremock1:8080;
        server wiremock2:8080;
        server wiremock3:8080;
    }

    server {
        listen 80;
        
        location = /__admin/mappings/import {
            mirror /wiremock1;
            mirror /wiremock2;
            proxy_pass http://wiremock3:8080/__admin/mappings/import;
        }
        
        location = /wiremock1 {
            internal;
            proxy_pass http://wiremock1:8080/__admin/mappings/import;
        }
        
        location = /wiremock2 {
            internal;
            proxy_pass http://wiremock2:8080/__admin/mappings/import;
        }

        location / {
            proxy_pass http://wiremock;
        }
    }
}
```

И перезапустим контейнер:
```
docker restart nginx
```

Для загрузки набора заглушек необходимо осуществить обращение на адрес балансировщика с указанием пути: 
`http://localhost:8083/__admin/mappings/import`.

И если раньше при загрузке набора по этому адресу и пути происходил импорт заглушек только в один из запущенных 
экземпляров Wiremock-сервера, то сейчас при запросе пути `/__admin/mappings/import` происходит зеркалирование запросов 
на первые два экземпляра Wiremock-сервера, затем отправка этого же запроса на третий сервер.

> Зеркалирование входящих запросов не даёт возможности понять корректно ли выполнен запрос со стороны Nginx к 
> экземпляру Wiremock. Поэтому может случиться так, что один из экземпляров в процессе загрузки упадёт и узнать это будет  
> невозможно до непосредственного обращения к данному экземпляру.

## Заключение

Wiremock – достаточно серьёзный инструмент для тестирования и управления заглушками. Его применение и использование не 
ограничивается методами, описанными в статье. Помимо работы с интерфейсами администрирования посредством HTTP-запросов 
существуют различные библиотеки облегчающие взаимодействие с Wiremock-сервером. Для дальнейшего обучения рекомендую 
обратиться к документации на официальном сайте проекта: https://wiremock.org/docs/overview/

## Глоссарий

- заглушки (mocks, моки) – сущности для подмены реальных ответов от сервисов;
- backend (back, бэк) – серверное приложение, отвечающее за логику обработки данных и запросов;
- frontend (front, фронт) – клиентское приложение, которое выполняется, например, в браузере;
- задержка ответа (latency) – время, которое проходит с момента отправки клиентом запроса и до момента получения ответа 
  на него;
- экземпляр (instance, инстанс) Wiremock-сервера – один из запущенных Wiremock-серверов, изолированный от других.
# Wiremock

## Для чего нужен Wiremock?

В больших распределённых системах часто возникают ситуации, когда один или несколько сервисов работают некорректно. Это 
ведёт к тому, что тестируемая система начинает сбоить и блокировать тестирование, тем самым возможны задержки в разработке 
и поставке нового функционала для бизнеса. Для большого продукта это очень критично в виду того, что подобные задержки 
ведут к общему увеличению стоимости нового функционала.

Типичная схема взаимодействия сервисов выглядит следующим образом:

![Интеграция приложения с backend](integration_ok.png)

Проблемы на стороне какого-либо сервиса ведут к тому, что вся система работает некорректно:

![Проблемы с сервисами](services_problem.png)

Для того, чтобы избежать таких ситуаций во многих командах в Леруа для тестов стараются минимизировать зависимость от 
сторонних сервисов, используя вместо них заглушки (mocks, моки). Наиболее удобным инструментом для создания заглушек 
является Wiremock.

Тестируемая система настраивается таким образом, чтобы в качестве backend (back, бэк) использовался Wiremock:

![Интеграция приложения с Wiremock](wiremock_integration.png)

## Установка Wiremock

Для запуска Wiremock-сервера можно использовать Docker и официальный образ:
`docker run -it --rm -p 8080:8080 --name wiremock wiremock/wiremock:3.0.4`

После скачивания и монтирования образа, Wiremock-сервер будет доступен по адресу: `http://localhost:8080/`

## Взаимодействие с Wiremock

Взаимодействие с запущенным Wiremock-сервером осуществляется посредством отправки HTTP-запросов в двух направлениях:
1. Администрирование.
2. Вызов сохранённых заглушек.

### Администрирование

Администрирование позволяет осуществлять различные манипуляции с сервером. Для этого существует REST API интерфейс 
`http://localhost:8080/__admin/{handler}`. С помощью этого интерфейса возможно (в скобках название ручек):
- управление заглушками (mappings);
- журналирование запросов (requests);
- учёт некорректных заглушек (near-misses);
- запись событий (recordings);
- управление состояниями сценариев (scenarios);
- изменение системных настроех Wiremock-сервера (settings, reset, shutdown).

Для получения детальной информации по доступным методам можно перейти по адресу `{wiremock_url}/__admin/swagger-ui/`.

### Вызов сохранённых заглушек

Вызов заглушек осуществляется выполнением HTTP-запроса на адрес `http://localhost:8080/{mock_path}`, где `mock_path` - 
путь к заглушке, которая ранее была загружена через интерфейс администрирования для управления заглушками.

## Работа с заглушками на примере Postman-коллекции:

ВНИМАНИЕ! Все совпадения случайны.

Для интерактивного знакомства с возможностями Wiremock-сервера, добавим некоторые вводные. Пусть в качестве тестируемой
системы у нас будет веб-приложение оформления заказа в интернет-магазине. Приложение будет состоять из трёх страниц:
- корзина;
- оформление заказа;
- спасибо за покупку.

Вот описание бэка, с которым будет взаимодействовать наш frontend (front, фронт):

![Как выглядит бэк](scheme.png)

На каждой странице вызываются свои методы.

Так, на странице корзины вызываются:
- `GET products` (получает расширенную информацию о товарах по их кодам);
- `POST orders` (создаёт черновик заказа).

На странице оформления вызываются:
- `POST ffo` (создаёт черновик заявки на самовывоз);
- `PUT ffo` (устанавливает пункт самовывоза в заявке на самовывоз для будущего заказа);
- `PATCH orders` (вносит изменения в заказ, например, при вводе ФИО);
- `POST confirm` (подтверждает оформление заказа).

На странице "Спасибо за покупку" вызывается метод `GET orders` (отображает покупателю информацию о созданном заказе).

Так как ни описанного сервиса, ни фронта не существует, мы просто будем симулировать их работу с помощью Postman и 
Wiremock.

> Используем Postman, чтобы не опираться на голую теорию и добавить немного интерактива. В 
> [этой коллекции](postman_wiremock.json) можно найти пару примеров взаимодействия с этим сервисом, а также 
> необходимые заглушки.
> Последовательность использования коллекции следующая:
> - запустить Wiremock-сервер;
> - отправить заглушки из коллекции на запущенный сервер;
> - отправлять запросы к заглушкам сервиса.

В данной коллекции для отправки заглушек на запущенный Wiremock-сервер используется метод 
`POST /__admin/mappings/import`. В него передаётся массив заглушек в следующем виде:
```
{
    mappings" : [
        {заглушка 1},
        {заглушка 2}
    ]
}
```

Для заглушки минимальный набор параметров может быть следующим:
```
{
    "request": {
        "method": "GET",
        "urlPath": "/api/products/",
        "queryParameters": {
            "in_cart": {
                "equalTo": "10001:1,10002:3,10005:20.5"
            }
        }
    },
    "response": {
        "status": 200,
        "headers": {
            "Content-Type": "application/json"
        },
        "jsonBody": [
            {
                "id": "10001",
                "name": "Рюкзак Erhaft Star M-2357",
                "stock": 12,
                "weight": 15.5
            },
            {
                "id": "10002",
                "name": "Пюре ФрутоНяня из говядины с овощами 100 г с 8 месяцев",
                "stock": 60,
                "weight": 2.3
            },
            {
                "id": "10005",
                "name": "Каша Fleur Alpine безмолочная гречневая гипоаллергенная 175г с 4мес",
                "stock": 5.5,
                "weight": 1
            }
        ]
    }
}
```

Рассмотрим подробнее, из чего состоит заглушка:
1. `request` – объект, описывающий запрос, по которому Wiremock-сервер определяет запрошенную заглушку.
2. `response` – объект, описывающий ответ, который возвращается при запросе заглушки.

|            |                   | Описание поля                               |
|------------|-------------------|---------------------------------------------|
| `request`  |                   |                                             |
|            | `method`          | HTTP-метод запроса                          |
|            | `urlPath`         | путь до заглушки без учёта query-параметров |
|            | `queryParameters` | объект, описывающий query-параметры запроса |
| `response` |                   |                                             |
|            | `status`          | HTTP-код статуса ответа                     |
|            | `headers`         | объект, описывающий заголовки ответа        |
|            | `jsonBody`        | JSON-объект (или массив) с телом ответа     |

**TO BE DONE**

Администрирование:
- структура мока, структура массива моков;
- загрузка моков;
- управление сценариями;
- сброс моков, сброс состояния сценариев.

Работа с заглушками:
- по url:
  - urlPath;
  - url;
  - urlPattern;
  - urlPathPattern;
  - urlPathTemplate.
- по заголовкам;
- по queryParameters;
- по body;
- по basicAuth;

- сравнение:
  - equalTo;
  - equalTo (caseInsensitive);
  - contains;
  - doesNotContain;
  - matches;
  - doesNotMatch;
  - equalToJson (ignoreArrayOrder, ignoreExtraElements, jsonUnit placeholders);
  - matchesJsonPath (expression, contains);
  - matchesXPath;
  - absent;

## Интеграция в автотесты.

**TO BE DONE**

Описать текущую архитектуру работы с моками в проекте автотестов.

## Развёртывание и распределение нагрузки.

**TO BE DONE**

Общий mappings для всех инстансов через Kubernetes или дублирование mappings для каждого инстанса.

![Как выглядит бэк](nginx_balancer.png)

## Использование Wiremock для нагрузочных тестов.

**TO BE DONE**

Задержка ответа, тип задержки ответа (log normal, uniform)